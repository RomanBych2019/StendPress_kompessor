#include         <SoftwareSerial.h>                   //  Подключаем библиотеку для работы по программной шине UART
#include         <Adafruit_Thermal.h>                 //  Подключаем библиотеку для работы с принтером
SoftwareSerial   mySerial(5, 6);                      //  Объявляем объект библиотеки SoftwareSerial, указывая задействованные выводы Arduino (RX=5-зелёный, TX=6-синий). Можно назначить другие выводы Arduino
Adafruit_Thermal printer(&mySerial);                  //  Объявляем объект библиотеки Adafruit_Thermal, указывая ссылку на созданный ранее объект mySerial библиотеки SoftwareSerial
char*            RUS(char*);                          //  Объявляем функцию перевода русских символов из кодировки UTF-8 в кодировку CP866
                                                      //
void setup(){                                         //  Код функции setup выполняется только 1 раз, при старте скетча
    mySerial.begin(9600);                             //  Инициируем передачу данных по программной шине UART на скорости 9600. Функцию begin объекта mySerial нужно вызвать до вызова функции begin объекта printer!
    printer.begin();                                  //  Инициируем работу с термопринтером. В качестве параметра можно указать время нагрева пикселей от 3 (0,03 мс) до 255 (2,55 мс), чем выше тем темнее пикселы. Значение по умолчанию = 120 (1,20 мс)
    printer.setCodePage(CODEPAGE_CP866);              //  Устанавливаем кодовую таблицу CP866 с поддержкой русского языка
    printer.setLineHeight(24);                        //  Устанавливаем межстрочный интервал в 2,4 мм (равен высоте текста), чтоб вертикальные линии таблицы не имели промежутков
    printer.write(0xC9);                              //  Выводим символ ╔
    for(int i=0; i<29; i++){printer.write(0xCD);}     //  Выводим символ ═ в цикле (29 символов в одной строке). Ширина таблицы 31 символ, а не 32 (максимальное число символов в строке), для того что бы ячейки таблицы были одинаковой ширины
    printer.write(0xBB);                              //  Выводим символ ╗
    printer.feed();                                   //  Прокручиваем ленту на 1 строку, для перехода на новую строку. В этом месте можно было бы написать printer.println("") или printer.print("\r\n"), но printer.feed() действует быстрее
    printer.write(0xBA);                              //  Выводим символ ║
    for(int i=0; i<9; i++){printer.write(0x20);}      //  Выводим пробел в цикле (9 пробелов в одной строке)
    printer.print(RUS("IARDUINO.RU"));                //  Выводим текст без перехода на новую строку
    for(int i=0; i<9; i++){printer.write(0x20);}      //  Выводим пробел в цикле (9 пробелов в одной строке)
    printer.write(0xBA);                              //  Выводим символ ║
    printer.feed();                                   //  Прокручиваем ленту на 1 строку, для перехода на новую строку. В этом месте можно было бы написать printer.println("") или printer.print("\r\n"), но printer.feed() действует быстрее
    printer.write(0xCC);                              //  Выводим символ ╠
    for(int i=0; i<14; i++){printer.write(0xCD);}     //  Выводим символ ═ в цикле (14 символов в одной строке)
    printer.write(0xD1);                              //  Выводим символ ╤
    for(int i=0; i<14; i++){printer.write(0xCD);}     //  Выводим символ ═ в цикле (14 символов в одной строке)
    printer.write(0xB9);                              //  Выводим символ ╣
    printer.feed();                                   //  Прокручиваем ленту на 1 строку, для перехода на новую строку. В этом месте можно было бы написать printer.println("") или printer.print("\r\n"), но printer.feed() действует быстрее
    printer.write(0xBA);                              //  Выводим символ ║
    for(int i=0; i<5; i++){printer.write(0x20);}      //  Выводим пробел в цикле (5 пробелов в одной строке)
    printer.print(RUS("ВСЁ"));                        //  Выводим текст без перехода на новую строку
    for(int i=0; i<6; i++){printer.write(0x20);}      //  Выводим пробел в цикле (6 пробелов в одной строке)
    printer.write(0xB3);                              //  Выводим символ │
    for(int i=0; i<5; i++){printer.write(0x20);}      //  Выводим пробел в цикле (5 пробелов в одной строке)
    printer.print(RUS("ДЛЯ"));                        //  Выводим текст без перехода на новую строку
    for(int i=0; i<6; i++){printer.write(0x20);}      //  Выводим пробел в цикле (6 пробелов в одной строке)
    printer.write(0xBA);                              //  Выводим символ ║
    printer.feed();                                   //  Прокручиваем ленту на 1 строку, для перехода на новую строку. В этом месте можно было бы написать printer.println("") или printer.print("\r\n"), но printer.feed() действует быстрее
    printer.write(0xC7);                              //  Выводим символ ╟
    for(int i=0; i<14; i++){printer.write(0xC4);}     //  Выводим символ ─ в цикле (14 символов в одной строке)
    printer.write(0xC5);                              //  Выводим символ ┼
    for(int i=0; i<14; i++){printer.write(0xC4);}     //  Выводим символ ─ в цикле (14 символов в одной строке)
    printer.write(0xB6);                              //  Выводим символ ╢
    printer.feed();                                   //  Прокручиваем ленту на 1 строку, для перехода на новую строку. В этом месте можно было бы написать printer.println("") или printer.print("\r\n"), но printer.feed() действует быстрее
    printer.write(0xBA);                              //  Выводим символ ║
    for(int i=0; i<4; i++){printer.write(0x20);}      //  Выводим пробел в цикле (4 пробела в одной строке)
    printer.print(RUS("РАДИО"));                      //  Выводим текст без перехода на новую строку
    for(int i=0; i<5; i++){printer.write(0x20);}      //  Выводим пробел в цикле (5 пробелов в одной строке)
    printer.write(0xB3);                              //  Выводим символ │
    for(int i=0; i<2; i++){printer.write(0x20);}      //  Выводим пробел в цикле (2 пробела в одной строке)
    printer.print(RUS("ЛЮБИТЕЛЕЙ"));                  //  Выводим текст без перехода на новую строку
    for(int i=0; i<3; i++){printer.write(0x20);}      //  Выводим пробел в цикле (3 пробела в одной строке)
    printer.write(0xBA);                              //  Выводим символ ║
    printer.feed();                                   //  Прокручиваем ленту на 1 строку, для перехода на новую строку. В этом месте можно было бы написать printer.println("") или printer.print("\r\n"), но printer.feed() действует быстрее
    printer.write(0xC8);                              //  Выводим символ ╚
    for(int i=0; i<14; i++){printer.write(0xCD);}     //  Выводим символ ═ в цикле (14 символов в одной строке)
    printer.write(0xCF);                              //  Выводим символ ╧
    for(int i=0; i<14; i++){printer.write(0xCD);}     //  Выводим символ ═ в цикле (14 символов в одной строке)
    printer.write(0xBC);                              //  Выводим символ ╝
    printer.feed(4);                                  //  Прокручиваем ленту на 4 строки
    printer.setDefault();                             //  Устанавливаем настройки принтера по умолчанию.
                                                      //
}                                                     //
                                                      //
void loop(){}                                         //
                                                      //
char* RUS(char* str){                                                                                                                      // Определяем функцию которая преобразует код русских символов из кодировки UTF-8 в кодировку CP866
    uint8_t i=0, j=0;                                                                                                                      // Определяем переменные: i - счетчик входящих символов, j - счетчик исходящих символов
    while(str[i]){                                                                                                                         // Проходим по всем символам строки str, пока не встретим символ конца строки (код 0)
        if(uint8_t(str[i]) == 0xD0 && uint8_t(str[i+1]) >= 0x90 && uint8_t(str[i+1]) <= 0xBF ){str[j] = (uint8_t) str[i+1]-0x10; i++;}else // Символы «А-Я а-п» (код UTF-8: D090-D0AF D0B0-D0BF) сохраняем в кодировке CP866: код 80-9F A0-AF (символ занимал 2 байта, а стал занимать 1 байт)
        if(uint8_t(str[i]) == 0xD1 && uint8_t(str[i+1]) >= 0x80 && uint8_t(str[i+1]) <= 0x8F ){str[j] = (uint8_t) str[i+1]+0x60; i++;}else // Символы «р-я»     (код UTF-8: D180-D18F)           сохраняем в кодировке CP866: код E0-EF       (символ занимал 2 байта, а стал занимать 1 байт)
        if(uint8_t(str[i]) == 0xD0 && uint8_t(str[i+1]) == 0x81                              ){str[j] = 0xF0;                    i++;}else // Символ «Ё»        (код UTF-8: D081)                сохраняем в кодировке CP866: код F0          (символ занимал 2 байта, а стал занимать 1 байт)
        if(uint8_t(str[i]) == 0xD1 && uint8_t(str[i+1]) == 0x91                              ){str[j] = 0xF1;                    i++;}else // Символ «ё»        (код UTF-8: D191)                сохраняем в кодировке CP866: код F1          (символ занимал 2 байта, а стал занимать 1 байт)
                                                                                              {str[j] = (uint8_t) str[i];}  j++; i++;      // Остальные символы оставляем как есть, без преобразования, но их место в строке могло сдвинуться, если до них были встречены русские символы
    }   while(j<i){str[j]=0; j++;} return str;                                                                                             // Так как место занимаемое символами в строке могло уменьшиться, заполняем оставшиеся байты символами конца строки (код 0)
}
